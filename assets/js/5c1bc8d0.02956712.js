"use strict";(self.webpackChunkmy_own_blog=self.webpackChunkmy_own_blog||[]).push([[6771],{7828:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"pico-ctf/binary-exploitation/heap-0","title":"heap 0","description":"- Description: Are overflows just a stack concern?","source":"@site/docs/pico-ctf/binary-exploitation/heap-0.mdx","sourceDirName":"pico-ctf/binary-exploitation","slug":"/pico-ctf/binary-exploitation/heap-0","permalink":"/my-small-blog/docs/pico-ctf/binary-exploitation/heap-0","draft":false,"unlisted":false,"tags":[{"inline":false,"label":"Binary Exploitation","permalink":"/my-small-blog/docs/tags/binary-exploitation","description":"Binary exploitation tag description"}],"version":"current","frontMatter":{"tags":["binary-exploitation"]},"sidebar":"tutorialSidebar","previous":{"title":"format string 0","permalink":"/my-small-blog/docs/pico-ctf/binary-exploitation/format-string-0"},"next":{"title":"PIE TIME","permalink":"/my-small-blog/docs/pico-ctf/binary-exploitation/pie-time"}}');var t=r(4848),o=r(8453);const s={tags:["binary-exploitation"]},c="heap 0",a={},l=[{value:"\ud83d\udd0e Solution",id:"-solution",level:2},{value:"\ud83d\udea9Flag",id:"flag",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"heap-0",children:"heap 0"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Are overflows just a stack concern?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Difficulty:"})," Easy"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-solution",children:"\ud83d\udd0e Solution"}),"\n",(0,t.jsx)(n.p,{children:"Upon inspecting the source code, we observe that the program allocates 2 heap variables as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'input_data = malloc(INPUT_DATA_SIZE);\r\nstrncpy(input_data, "pico", INPUT_DATA_SIZE);\r\n\r\nsafe_var = malloc(SAFE_VAR_SIZE);\r\nstrncpy(safe_var, "bico", SAFE_VAR_SIZE);\n'})}),"\n",(0,t.jsx)(n.p,{children:"After connecting to the server, we're presented with a simple interactive menu offering several options:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"1. Print Heap        (print the current state of the heap)\r\n2. Write to buffer   (write to your own personal block of data on the heap)\r\n3. Print safe_var    (I'll even let you look at my variable on the heap, I'm confident it can't be modified)\r\n4. Print Flag        (Try to print the flag, good luck)\r\n5. Exit\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To retrieve the flag using option 4, we need to pass the condition in the ",(0,t.jsx)(n.code,{children:"check_win()"})," function.\r\nSpecifically, we must modify the contents of ",(0,t.jsx)(n.code,{children:"safe_var"}),' so that it no longer equals "bico":']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'void check_win() {\r\n    if (strcmp(safe_var, "bico") != 0) {\r\n        printf("\\nYOU WIN\\n");\r\n\r\n        // Print flag\r\n        char buf[FLAGSIZE_MAX];\r\n        FILE *fd = fopen("flag.txt", "r");\r\n        fgets(buf, FLAGSIZE_MAX, fd);\r\n        printf("%s\\n", buf);\r\n        fflush(stdout);\r\n\r\n        exit(0);\r\n    } else {\r\n        printf("Looks like everything is still secure!\\n");\r\n        printf("\\nNo flag for you :(\\n");\r\n        fflush(stdout);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Looking at how user input is handled, we find the following function tied to option 2:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'void write_buffer() {\r\n    printf("Data for buffer: ");\r\n    fflush(stdout);\r\n    scanf("%s", input_data);\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The key vulnerability here is the use of ",(0,t.jsx)(n.code,{children:'scanf("%s", ...)'})," without bounds checking.\r\nSince ",(0,t.jsx)(n.code,{children:"input_data"})," resides before ",(0,t.jsx)(n.code,{children:"safe_var"})," on the heap, overflowing ",(0,t.jsx)(n.code,{children:"input_data"})," allows us to overwrite ",(0,t.jsx)(n.code,{children:"safe_var"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Selecting option 1 (Print Heap) reveals the following state:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Heap State:\r\n+-------------+----------------+\r\n[*] Address   ->   Heap Data   \r\n+-------------+----------------+\r\n[*] 0x5ac3adc6f2b0  ->   pico\r\n+-------------+----------------+\r\n[*] 0x5ac3adc6f2d0  ->   bico\r\n+-------------+----------------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"From this, we infer that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"input_data"})," is located at ",(0,t.jsx)(n.code,{children:"0x5ac3adc6f2b0"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"safe_var"})," is located at ",(0,t.jsx)(n.code,{children:"0x5ac3adc6f2d0"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Calculating the offset:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"(gdb) p/x 0x5ac3adc6f2d0 - 0x5ac3adc6f2b0\r\n$2 = 0x20\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This gives an offset of ",(0,t.jsx)(n.strong,{children:"0x20"})," bytes (or ",(0,t.jsx)(n.strong,{children:"32"})," in decimal) between the 2 heap chunks."]}),"\n",(0,t.jsxs)(n.p,{children:["Now, to overwrite ",(0,t.jsx)(n.code,{children:"safe_var"}),", we simply input any string ",(0,t.jsx)(n.em,{children:"longer than 32 characters"})," when prompted by option 2.\r\nFor example, I use ",(0,t.jsx)(n.code,{children:"abcdefghabcdefghabcdefghabcdefgh1"}),".\r\nThis input overflows past ",(0,t.jsx)(n.code,{children:"input_data"})," and modifies ",(0,t.jsx)(n.code,{children:"safe_var"}),", changing its value and causing the strcmp in ",(0,t.jsx)(n.code,{children:"check_win()"})," to succeed."]}),"\n",(0,t.jsx)(n.p,{children:"Now, choosing option 4 (Print Flag) will trigger the win condition and print the flag."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Enter your choice: 4\r\n\r\nYOU WIN\r\npicoCTF{my_first_heap_overflow_4fa6dd49}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"flag",children:"\ud83d\udea9Flag"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"picoCTF{my_first_heap_overflow_4fa6dd49}"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var i=r(6540);const t={},o=i.createContext(t);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);