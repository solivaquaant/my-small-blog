"use strict";(self.webpackChunkmy_own_blog=self.webpackChunkmy_own_blog||[]).push([[8735],{87676:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/dll-side-loading-notepadpp","metadata":{"permalink":"/my-small-blog/blog/dll-side-loading-notepadpp","source":"@site/blog/dll-side-loading-notepadpp/index.mdx","title":"Exploring DLL Side Loading: A practical walkthrough using Notepad++","description":"Blog","date":"2025-09-30T02:41:55.000Z","tags":[{"inline":false,"label":"Malware","permalink":"/my-small-blog/blog/tags/malware","description":"Malware tag description"}],"readingTime":5.4,"hasTruncateMarker":true,"authors":[{"name":"Thai Trinh","title":"Cybersecurity Student @ UIT","url":"https://github.com/solivaquaant","page":{"permalink":"/my-small-blog/blog/authors/tndt"},"imageURL":"/my-small-blog/img/avt-trans.png","key":"tndt"}],"frontMatter":{"authors":"tndt","tags":["malware"],"description":"Blog"},"unlisted":false,"nextItem":{"title":"Stego secrets: Extracting embedded files using HxD and dd","permalink":"/my-small-blog/blog/nt334-lab2-ctf"}},"content":"In today\'s blog post, we\'re diving into DLL Side Loading - a technique often exploited by attackers to execute malicious code by abusing the way Windows searches for and loads dynamic link libraries.\\r\\nWe\'ll break down how DLL Side Loading works, how the Windows DLL search order contributes to the vulnerability, and walk through a practical example using Notepad++ as our target application.\\r\\n{/* truncate */}\\r\\n> \u26a0\ufe0f Disclaimer  \\r\\n> This article is for **educational** and **ethical** purposes only. \\r\\n\\r\\n## Understanding DLLs and DLL Side Loading\\r\\n**Dynamic link libraries (DLLs)** are modular components that contain code and data used by multiple programs simultaneously. \\r\\nDLLs help reduce redundancy and optimize memory usage across Windows systems.\\r\\n\\r\\n**DLL Side Loading** is a technique where an attacker places a malicious DLL in a location where a legitimate application may inadvertently load it instead of the intended one. \\r\\nThis often happens due to the **Windows DLL Search Order**, which prioritizes certain directories (like the application\'s folder) over system directories when loading libraries.\\r\\nBy exploiting this search behavior, attackers can trick applications into executing their malicious payloads without modifying the target application itself.\\r\\n\\r\\n## Tools & setup\\r\\nFor this walkthrough, we\'ll be using the following tools and setup:\\r\\n- Target: Notepad++ v8.7.7\\r\\n- ProcMon (Sysinternals): Monitor DLL loading and process activity\\r\\n- x64dbg: Reverse-engineering and binary analysis\\r\\n- Visual Studio: Compile our custom DLLs\\r\\n- Sliver C2: Open-source C2 framework\\r\\n\\r\\nEnvironment:\\r\\n- Victim: Windows 10/11\\r\\n- Attacker: Kali Linux\\r\\n- Network: NAT (VMware)\\r\\n\\r\\n## Case study: GUP.exe in Notepad++\\r\\nNotepad++ ships with an updater utility called **GUP.exe (Generic Updater)**. \\r\\nIt typically resides in `C:\\\\Program Files\\\\Notepad++\\\\updater\\\\GUP.exe`.\\r\\nThis executable checks for and installs updates for Notepad++ or its plugins. \\r\\nWhen run, it prompts a software update popup and loads several files from its directory, including:\\r\\n- `GUP.exe`\\r\\n- `libcurl.dll` -a dynamic library from the cURL project for network communication\\r\\n- `gup.xml` - configuration file for update behavior\\r\\n\\r\\nBy using **ProcMon**, we observe that `GUP.exe` loads `libcurl.dll` from the local directory, making it an *ideal* candidate for DLL Side Loading.\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./procmon.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\n## Crafting the first malicious DLL\\r\\nTo test the loading behavior, we create a simple malicious `libcurl.dll` with a MessageBox payload:\\r\\n```cpp\\r\\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {\\r\\n    switch (ul_reason_for_call) {\\r\\n    case DLL_PROCESS_ATTACH:\\r\\n        MessageBoxA(NULL, \\"Group-CK13\\", \\"Simple DLL\\", MB_OK | MB_ICONEXCLAMATION);\\r\\n        break;\\r\\n    }\\r\\n    return TRUE;\\r\\n}\\r\\n```\\r\\nReplace the original `libcurl.dll` with our malicious version and execute `GUP.exe`. \\r\\nWe notice 2 things in **ProcMon**:\\r\\n- Our malicious DLL was successfully loaded\\r\\n- GUP.exe crashes due to missing exported functions like `curl_easy_setopt`\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./error.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\n## Identifying and exporting required functions\\r\\nThe crash occurs because `GUP.exe` expects `libcurl.dll` to expose certain functions, which our malicious DLL lacks.\\r\\nTo identify them, use `dumpbin /IMPORTS GUP.exe` in the Visual Studio command prompt to inspect the **Import Address Table (IAT)**:\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./dumpbin.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\nYou\'ll find it imports these 4 functions: `curl_easy_init`, `curl_easy_setopt`, `curl_easy_cleanup`, `curl_easy_perform`\\r\\n\\r\\nWe modify our DLL to export these functions, with `curl_easy_init` triggering our MessageBox:\\r\\n```cpp\\r\\nextern \\"C\\" __declspec(dllexport) PVOID curl_easy_init() {\\r\\n    MessageBoxA(NULL, \\"Group-CK13\\", \\"Simple DLL\\", MB_OK | MB_ICONEXCLAMATION);\\r\\n    return NULL;\\r\\n}\\r\\nextern \\"C\\" __declspec(dllexport) PVOID curl_easy_setopt() { return NULL; }\\r\\nextern \\"C\\" __declspec(dllexport) PVOID curl_easy_cleanup() { return NULL; }\\r\\nextern \\"C\\" __declspec(dllexport) PVOID curl_easy_perform() { return NULL; }\\r\\n```\\r\\n\\r\\nNow, when running `GUP.exe`, we see the MessageBox as intended.\\r\\n<div style={{ width: \'60%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./init.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\n## Combining with DLL proxying for stealth and functionality\\r\\nHowever, if we proceed as described above, when the user runs GUP.exe (or updates Notepad++), \\r\\nthey will not see the original Message Box of the application and will not be able to perform the original functionality.\\r\\n\\r\\nTherefore, we combine this with the **DLL proxying** technique - a method used to intercept function calls that are originally directed to a legitimate DLL file. \\r\\nThis is done by creating an intermediary DLL, called a Proxy DLL, which exports the same functions as the original DLL.\\r\\n\\r\\nSteps:\\r\\n1. Rename the original DLL file to `gup.dll`\\r\\n2. Add the following `#pragma` comment directives:\\r\\n- These are linker directives used to export functions just like the original DLL, but in fact, they forward the calls to the real DLL, which is now `gup.dll`\\r\\n- Syntax: `/export:function_name=originalDLL.function_name,@ordinal`\\r\\n```cpp\\r\\n#pragma comment(linker, \\"/export:curl_easy_cleanup=gup.curl_easy_cleanup,@1\\")\\r\\n#pragma comment(linker, \\"/export:curl_easy_init=gup.curl_easy_init,@6\\")\\r\\n#pragma comment(linker, \\"/export:curl_easy_perform=gup.curl_easy_perform,@12\\")\\r\\n#pragma comment(linker, \\"/export:curl_easy_setopt=gup.curl_easy_setopt,@16\\")\\r\\n```\\r\\n- Ordinal values: These are the index numbers of the exported functions, which can be viewed in tools like `x64dbg`.\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./x64.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\nWrite a `DoMagic()` function to display a MessageBox. \\r\\nThis should run in a separate thread to avoid blocking the main process:\\r\\n```cpp\\r\\nDWORD WINAPI DoMagic(LPVOID lpParameter)\\r\\n{\\r\\n    MessageBoxA(NULL, \\"Group-CK13\\", \\"Simple DLL\\", MB_OK | MB_ICONEXCLAMATION);\\r\\n    return 0;\\r\\n}\\r\\n```\\r\\nWhen the DLL is loaded (`DLL_PROCESS_ATTACH`), it creates a new thread to run `DoMagic()`:\\r\\n```cpp\\r\\ncase DLL_PROCESS_ATTACH:\\r\\n    threadHandle = CreateThread(NULL, 0, DoMagic, NULL, 0, NULL);\\r\\n    CloseHandle(threadHandle);\\r\\n    break;\\r\\n```\\r\\nAt this point, when `GUP.exe` is run again, both the original Message Box from the application and the injected (malicious) Message Box will appear.\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./proxy.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\n## Establishing remote control with Sliver C2\\r\\nTo escalate the attack, we can modify the `DoMagic()` function to establish a reverse shell or C2 session. \\r\\nIn this case, we used Sliver C2 on a Linux machine. \\r\\nOnce the user launches GUP.exe (e.g., by checking for updates), a session is established on the attacker\'s C2 interface.\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./c2.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\nFor persistence and stealth, additional techniques like process injection, registry persistence (run keys), shellcode obfuscation can be employed - though we won\'t detail them here due to ethical concerns.\\r\\n\\r\\n## Conclusion\\r\\nDLL Side Loading is a powerful and commonly abused technique in the wild. By understanding how it works, defenders can:\\r\\n- Audit how applications load DLLs\\r\\n- Harden directory permissions\\r\\n- Implement application whitelisting\\r\\n- Monitor abnormal DLL load behavior with tools like ProcMon\\r\\n\\r\\nFrom a red team or educational perspective, this hands-on walkthrough using Notepad++ shows just how easy it can be to hijack execution flow when the right conditions align.\\r\\n\\r\\n*Stay safe. Stay informed.*"},{"id":"/nt334-lab2-ctf","metadata":{"permalink":"/my-small-blog/blog/nt334-lab2-ctf","source":"@site/blog/nt334-lab2-ctf/index.mdx","title":"Stego secrets: Extracting embedded files using HxD and dd","description":"Write-up of a CTF challenge from Digital Forensics course, focusing on steganography techniques to extract hidden files.","date":"2025-09-30T02:41:55.000Z","tags":[{"inline":false,"label":"Steganography","permalink":"/my-small-blog/blog/tags/steganography","description":"Steganography tag description"},{"inline":false,"label":"CTF","permalink":"/my-small-blog/blog/tags/ctf","description":"CTF tag description"}],"readingTime":1.54,"hasTruncateMarker":true,"authors":[{"name":"Thai Trinh","title":"Cybersecurity Student @ UIT","url":"https://github.com/solivaquaant","page":{"permalink":"/my-small-blog/blog/authors/tndt"},"imageURL":"/my-small-blog/img/avt-trans.png","key":"tndt"}],"frontMatter":{"authors":"tndt","tags":["steganography","ctf"],"description":"Write-up of a CTF challenge from Digital Forensics course, focusing on steganography techniques to extract hidden files."},"unlisted":false,"prevItem":{"title":"Exploring DLL Side Loading: A practical walkthrough using Notepad++","permalink":"/my-small-blog/blog/dll-side-loading-notepadpp"},"nextItem":{"title":"Unmasking user activity: A deep dive into Windows TypedPaths","permalink":"/my-small-blog/blog/typed-paths"}},"content":"During Lab 2 of Digital Forensics course, we explored the topic of **Steganography**. \\r\\nAs part of the session, our instructor introduced a CTF-style challenge and offered bonus points to anyone who could successfully retrieve the flag.\\r\\n{/* truncate */}\\r\\n\\r\\n## Solution\\r\\nWe were provided with a video file and a hint: *\\"Look for the hex signature of a file that might be hidden inside.\\"*  \\r\\n\\r\\nTo begin, I opened the video file using **HxD**, a hex editor. \\r\\nUpon inspection, I noticed that the file header identified it as an `ftypisom` format, which is a common container signature for MP4 videos.  \\r\\n\\r\\nTo search for embedded file signatures, I used the **Search** function (`Ctrl + F`) in HxD. \\r\\nUnder **Text-string**, I looked for typical MP4 box types like:\\r\\n```\\r\\n\\"ftyp\\", \\"mdat\\", \\"moov\\", \\"pnot\\", \\"udta\\", \\"uuid\\", \\"moof\\", \\"free\\", ...\\r\\n```\\r\\nAlternatively, I could switch to **Hex-values** mode and search for hex representations of known file headers.  \\r\\n\\r\\nAfter some scanning, I found the following hex sequence:\\r\\n```\\r\\n66 74 79 70 6D 70 34 32\\r\\n```\\r\\nThis corresponds to the ASCII string `ftypmp42`, indicating the header of an **MP4 (version 2)** file. \\r\\nThis signature was located at **offset `0x1D62C78`**.\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./offset.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\nTo extract the embedded MP4 file, I first converted the offset to decimal: 0x1D62C78 = 30813300.  \\r\\n\\r\\nThen, using the `dd` command in a Unix-like environment, I extracted the hidden file:\\r\\n```bash\\r\\ndd if=video-challenge.mp4 of=output.mp4 bs=1 skip=30813300\\r\\n```\\r\\nOpening the extracted `output.mp4` revealed the flag for the challenge.\\r\\n<div style={{ width: \'80%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./flag.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\nThis exercise demonstrated how steganographic techniques can be used to conceal full files within other media, and how basic hex analysis combined with known file signatures can help uncover them.\\r\\n\\r\\n# Flag\\r\\n> `inseclab{b3h1nd_th3_sc3n3}`"},{"id":"/typed-paths","metadata":{"permalink":"/my-small-blog/blog/typed-paths","source":"@site/blog/typed-paths/index.mdx","title":"Unmasking user activity: A deep dive into Windows TypedPaths","description":"A blog about Typed Paths registry in Windows.","date":"2025-09-30T02:41:55.000Z","tags":[],"readingTime":4.34,"hasTruncateMarker":true,"authors":[{"name":"Thai Trinh","title":"Cybersecurity Student @ UIT","url":"https://github.com/solivaquaant","page":{"permalink":"/my-small-blog/blog/authors/tndt"},"imageURL":"/my-small-blog/img/avt-trans.png","key":"tndt"}],"frontMatter":{"authors":"tndt","tags":[],"description":"A blog about Typed Paths registry in Windows."},"unlisted":false,"prevItem":{"title":"Stego secrets: Extracting embedded files using HxD and dd","permalink":"/my-small-blog/blog/nt334-lab2-ctf"}},"content":"What if the Windows Registry kept a memory of every path you typed into Explorer? \\r\\nTyped Paths do exactly that-making them a goldmine for investigators tracking attacker movements.\\r\\n{/* truncate */}\\r\\n\\r\\n## What are Typed Paths & why do they matter in DFIR?\\r\\n**Typed Paths** are a forensic artifact found deep within the Windows Registry. \\r\\nEssentially, they record the paths (file, folder, or even commands) that a user has typed or pasted into the **File Explorer** (or Windows Explorer) address bar. \\r\\nTheir primary function is to power the convenient auto-complete feature for subsequent inputs.\\r\\n\\r\\nExamples of what\'s recorded:\\r\\n- `C:\\\\Windows\\\\System32`\\r\\n- `\\\\\\\\192.168.1.100\\\\share` (a network share)\\r\\n- `cmd`\\r\\n- `powershell`\\r\\n\\r\\nThink of it as the **Most Recently Used** (MRU) list for the Explorer\'s path bar.\\r\\n\\r\\nWhile simple, this artifact provides a crucial window into user (or attacker) behavior, specifically what commands they executed or what resources they tried to access.\\r\\nIt can quickly expose the telltale signs of unusual activity:\\r\\n- Running specific malware executables or scripts.\\r\\n- Accessing suspicious or external network shares (UNC paths).\\r\\n- Executing command-line tools like cmd, powershell, or mstsc directly from the path bar.\\r\\n\\r\\n## Where are Typed Paths stored?\\r\\nTyped Paths are a **per-user** structure, meaning the data is located within that specific user\'s hive file (`NTUSER.DAT`).\\r\\n\\r\\nThe Registry Key Location:\\r\\n- `HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\TypedPaths`\\r\\n\\r\\nIn a mounted offline hive, you\'d find it under: `HKEY_USERS\\\\<User-SID>\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\TypedPaths`\\r\\n\\r\\nThe sub-values are typically named `url1`, `url2`, `url3`, and so on, with a data type of `REG_SZ` (text string). \\r\\nCrucially, the newest path is almost always found in `url1`. \\r\\nWhen a new path is added, the older entries get \\"rolled down\\" to the next number.\\r\\n\\r\\n## What data can you expect to find?\\r\\nThe paths stored in TypedPaths can take various forms, offering rich context:\\r\\n- Folder Paths: `C:\\\\Users\\\\Alice\\\\Documents`\\r\\n- File/Executable Paths: `C:\\\\Temp\\\\installer.exe`\\r\\n- UNC Network Paths: `\\\\\\\\10.10.10.5\\\\share` or `\\\\\\\\attacker-server\\\\payload`\\r\\n- Simple Commands: `cmd`, `powershell`, `mstsc`\\r\\n\\r\\nURLs or other strings if an application or user inputs them into the address bar.\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  <img src={require(\\"./registry-ex.png\\").default} style={{ width: \'100%\', height: \'auto\' }} />\\r\\n</div>\\r\\n\\r\\n## The value in DFIR & threat hunting\\r\\nDespite its simplicity, TypedPaths can reveal the exact strings or commands an account attempted to run or access. \\r\\nThis is incredibly valuable for:\\r\\n- Spotting suspicious behavior: Identifying specific actions like connecting to an unfamiliar IP via UNC path, directly invoking a payload, or running an unusual binary.\\r\\n- Verifying the threat actor\'s path: Confirming if the attacker used the Run dialog box or Explorer\'s address bar to launch tools like `psexec` or `powershell`.\\r\\n- Detecting abnormal network access: Pinpointing attempts to access network resources that fall outside a user\'s normal scope of work.\\r\\n\\r\\nSince this is a per-user artifact, it\'s excellent for isolating and differentiating the actions taken by various accounts on a compromised machine.\\r\\n\\r\\n## How to collect Typed Paths\\r\\nYou generally have 2 main contexts for collection:\\r\\n\\r\\n### Live / On-system collection\\r\\nThis is useful for quick triage on a running system, but be mindful not to alter the registry state while analyzing.\\r\\n- **PowerShell**:\\r\\n    - Basic command (read urlN values):\\r\\n    ```\\r\\n    Get-ItemProperty -Path \\"HKCU:\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\TypedPaths\\"\\r\\n    ```\\r\\n    - Export to CSV (separating urlN into Key/Value columns) for storage or ingestion into an analysis pipeline:\\r\\n    ```\\r\\n    Get-ItemProperty -Path \\"HKCU:\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\TypedPaths\\" |\\r\\n        Select-Object -Property * |\\r\\n        ForEach-Object {\\r\\n            $props = $_.psobject.properties | Where-Object { $_.Name -match \'^url\' }\\r\\n            foreach ($p in $props) {\\r\\n                [PSCustomObject]@{ Key = $p.Name; Value = $p.Value }\\r\\n            }\\r\\n        } | Export-Csv -Path C:\\\\test.csv -NoTypeInformation -Encoding UTF8\\r\\n    ```\\r\\n\\r\\n- **reg.exe**: Export the key into a `.reg` file for backup/copy:\\r\\n```\\r\\nreg export \\"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\TypedPaths\\" typedpaths.reg\\r\\n```\\r\\n\\r\\n### Offline / image analysis\\r\\nThis is the safer, forensically sound method:\\r\\n- Load the Hive: You extract the `NTUSER.DAT` file from the relevant user\'s profile on the disk image.\\r\\n- Analyze: Load this hive copy into a dedicated forensic tool (like Registry Explorer) for read-only analysis.\\r\\n\\r\\n## Limitations\\r\\nTyped Paths are a great indicator, but they are not a \\"smoking gun\\" on their own:\\r\\n- Commit Time: Entries are not always immediate. If the Explorer window hasn\'t been closed, the entry might not have been \\"committed\\" to the registry yet.\\r\\n- No Per-Entry Timestamp: This is the biggest drawback. TypedPaths does not store an individual timestamp for each urlN value.\\r\\n- The only timestamp available is the **LastWriteTime** of the parent TypedPaths key (the last time any entry was added or modified).\\r\\n- Evasion: A user (or threat actor) can manually clear these registry values.\\r\\n- Windows Versions: The behavior, size, and even the exact storage path can sometimes vary between Windows versions.\\r\\n\\r\\nYou must correlate TypedPaths content with other artifacts-such as Prefetch, Shellbags, Event Logs, Amcache, UserAssist, or Sysmon-to accurately establish timelines and confidence levels.\\r\\n\\r\\n## Conclusion\\r\\nTyped Paths isn\'t a silver bullet, but it is an invaluable, intuitive, and fast source of intelligence-especially during initial triage or when other logging sources are incomplete. \\r\\nWhen collected, validated, and correlated properly, Typed Paths can significantly shorten your investigation time and expose specific, high-value suspicious behaviors left behind by an attacker.\\r\\n\\r\\n<div style={{ width: \'100%\', margin: \'0 auto\' }}>\\r\\n  {/* <img src={require(\\"./flag.png\\").default} style={{ width: \'100%\', height: \'auto\' }} /> */}\\r\\n</div>"}]}}')}}]);